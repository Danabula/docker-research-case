---
title: Praktisch docker
order: 1
active: 1
goto:
 type: subject
 index: 4
---

# Praktisch docker

**TODO** scenarios waarbij docker goede oplossing is
**TODO** makkelijk redundancy
wie hoe wat waar wanneer waarom docker
containers maken efficienter gebruikt van de host os resources dan virtuele machines, maar gebruiken dezelfde kernel als het host operating systeem
voor containers hoef je niet rekening te houden met de state vm configuraties, dat hoeft anders ook niet met een vm orchestrator
Docker is een runtime voor containers die de oci standaard gebruiken.
Containers zijn een lighte virtualisatie technologie gebouwd op de linux kernel.
Docker word gebruikt
- om programmas onafhankelijk van operating systeem en systeem configuratie op te zetten
    Dit betekend bijvoorbeeld dat je programmas die verschillende versies hebben op dezelfde computer kan draaien
- om te prototypen
    Als er iets verkeerd gaat met het opzetten van bijvoorbeeld een database,
    dan is dat heel gemakkelijk terug te zetten.
- om te experiementeren
    Als je met een container werkt is dat onafhankelijk van het operating systeem, dus je kan niet je firewall verknallen!
- voor security
    security werkt met lagen en de docker runtime isoleert het van het host systeem met de juiste configuraties
- termen container vs image


---
# Docker **architectuur**
**TODO human language**
docker heeft een client & server structuur
docker engine 
Een docker applicatie wordt ingepakt tot een container image.
Om die docker applicatie te draaien moet je eerst een instantie van die image creeen, een container
De docker workflow is dus net zoals classes en objects.


---
## geschiedenis
*TODO* geschiedenis van vms tot creatie docker


---
## Containers gebruiken

Laten we beginnen met het hello world programma!
```shell
docker run hello-world
```
Nu zie je docker een image downloaden van de standard image repository: dockerhub.  
Een image is een door docker ingepakt programma en dockerhub heeft images voor veel programmas,  
zoals de mysql en mariadb databases, nodejs, php, basis operating systeem images, apache httpd, nginx etc.  
Zo'n image (vergelijkbaar met een class) kan je niet direct draaien, docker maakt een container (vergelijkbaar met een instantie) aan om te draaien.  
Na het downloading draait docker de container.  
Je kan ook argumenten doorgeven naar het programma dat de entrypoint draait, Bijvoorbeeld.
```shell
# de node -e of --eval optie staat voor evalueren, oftewel: javascript draaien
docker run node -e 'console.log("Hello nodejs runtime!")'
```
Zo kan je bijvoorbeeld een logging level argument geven aan het programma.

Nu heeft docker nog wel de images.  
Gebruik docker image ls om de gedownloade images weer te geven.
```shell
docker image ls
```
Met docker kan je draaiende containers weergeven met
```shell
docker ps
```
Er is nu geen actieve container, het hello world programma is al klaar met draaien.  
Er zijn ook programmas die blijven draaien totdat de gebruiker het programma stopt (een daemon).

Bijvoorbeeld een simpel python programma dat een infinite loop heeft.
```shell
# zet de locatie waar je python-entrypoint.sh kan vinden relatief met de working directory
script="src/sources/loop.py"
docker run -d --rm -e "MESSAGE=Hello python!" -v "$script:/script.py:ro" python:3-alpine python -u /script.py
```
Okay, hier gebeurt heel wat, laten we het stap voor stap dismantelen.  
Als eerste de -d optie geeft aan dat docker de container in de achtergrond moet draaien, dus dat docker niet je terminal blokkeerd.  
De --rm optie geeft aan dat de container verwijderd moet worden als het stopt.
De -e of --env optie is om een environment variable te zetten voor de container, programmas kunnen dit lezen en het is dus handig om de mode van je applicatie te zetten voor productie.
De -v optie is om een file of directory in de container te mounten, oftewel de script.py file in de container verwijst
naar de loop.py file.
Dan komt de naam van de image, waarvan we een container willen draaien: python:3-alpine.
Dit is een image met een python interpreter (kan python files draaien net zoals nodejs voor javascript).  
En als laatst het commando dat we willen draaien "python -i /script.py": de python interpreter om het script te draaien

Als je nu docker ps invoert, zie je 1 lijn met de python container (te zien aan de image naam).
```shell
docker ps
```
De containers krijgen een random container id en naam bij creatie, zodat we containers kunnen onderscheiden.  
Die kunnen we gebruiken om een commando voor een specifieke container uit te voeren, zoals docker logs om container logs te bekijken.  
Je hoeft voor de container id alleen maar de eerste karakters in te voeren, om het te onderscheiden van andere containers.
```shell
docker logs container-id
# of
docker logs container-naam
```
Nu zie je dat het python programma elke seconde Hello python! heeft geprint.
Om een contain te stoppen gebruik je docker stop
```shell
docker stop container-id
```
Maar de container is dan niet verwijderd. Dit is nodig om bijvoorbeeld de logs te kunnen bekijken als een container crashed.  
Gebruik docker ps met de -a vlag om ook inactive/gestopte containers te bekijken.
```shell
docker ps -a
```
Om een gestopte container te verwijderen gebruik je docker rm
```shell
docker rm container-id
```

Dus om docker images te gebruiken en beheren gebruik je
```shell
# voor een container draaien
docker run image-id (cmd)
# met -d voor in de achtergrond en --rm om de container te verwijderen wanneer het gestopt is
# voor een lijst van draaiende containers weer te geven
docker ps
# voor een lijst van active en inactive containers
docker ps -a
# om de logs van een container te bekijken
docker logs container-id
# om een container verwijderen
docker rm container-id
```
Bekijk vooral nog andere docker run opties zoals -p voor port forwarden en -v voor filesysteem passtrough.
```shell
docker --help
```


---
## Container images

Een docker image werkt door lagen van applicaties te installeren & commandos te draaien op een andere image.  
Onder al die lagen zit een basis image, die wel speciale preperatie nodig heeft [base images](https://docs.docker.com/build/building/base-images/)  
Maar je werkt in de praktijk vrijwel altijd al met een base image, zoals debian of alpine linux.  
Net zoals je in windows en linux na een installatie allemaal programmas installeerd, doen we dat ook met docker images.  
Linux distributies gebruiken een package manager net zoals npm, composer etc. voor gewone programmas installeren.  
Om bijvoorbeeld videolan player te installeren op archlinux gebruik je de pacman package manager.
```shell
pacman -S vlc
```
Een package manager verifieerd package integeriteit en maakt het makkelijk om programmas te installeren en updaten.  
Nou zo'n docker image bouwen doe je met een **Dockerfile**.  
Een dockerfile is een text file met de volgende structuur:
```dockerfile
FROM debian:latest
# dit is waar je de base image kiest, hierzo debian van de standard repository (dockerhub) met de latest tag (de laatste versie).

RUN apt update && apt install neofetch
# de RUN instructie wordt gebruikt een commandos uit te voeren.
# hier updaten we eerst de package database, oftewel welke programmas de package manager het bestaan van weet.
# apt is het commando van de debian package manager aptitude.
# en (&&) hier installeren we het programma neofetch, dat wordt gebruikt om informatie over een operating systeem laat zien.

RUN echo hallo we zijn een image aan het bouwen!
# als we deze Dockerfile gebruiken om een image te bouwen, zullen we "hallo we zijn een image aan het bouwen!" te zien krijgen.
# het sh echo commando print naar stdout, oftewel het doet hetzelfde als echo en print in programmeer talen>

ENTRYPOINT [ "neofetch" ]
# entrypoint is het commando dat wordt gedraaid, als je een container van deze image gebruikt.
```
Elk commando creeert een laag die gehashd wordt met de inhoud en de hash van de vorige laag,  
deze hash kan docker gebruiken om lagen te dedupliceren,  
het zou namelijk onhandig zijn als elke image die je maakt een heel kopie maakt van de base image, dat zou veel opslag kosten.  
Dit is waarom je vaak alleen een deel van een image moet herbouwen bij een verandering in je dockerfile, omdat vorige lagen al gecached zijn.  
Je kan docker history gebruiken om de verschillende lagen van een image te weergeven.
```shell
docker history id
```
Andere dockerfile commands zijn COPY, CMD. Zie de [referentie](https://docs.docker.com/engine/reference/builder/).  
Om je docker image daadwerkelijk te bouwen gebruik je docker build.  
Open een shell in de Dockerfile folder.
```shell
# build een image van context folder (zoekt een Dockerfile in dezelfde folder)
docker build -t mijn-neofetch .
# of een specifieke Dockerfile
docker build -t mijn-neofetch -f Dockerfile
```
Nu download docker de debian image en gaat het laag voor laag bouwen.  
Je ziet als docker klaar is met bouwen na STEP 3/4 de lijn: 'hallo we zijn een image aan het bouwen!'  
Nu kunnen we neofetch in een container draaien met docker run.
```shell
docker run --rm mijn-neofetch
```
Zoals je kunt zien met docker image ls en het downloaden & builden van de image,  
gebruikt het gigantisch veel disk ruimte voor alleen maar een mooi print programma.  
Een veelgebruikte operating systeem en docker base image is alpine linux, omdat het heel klein is.  
De alpine docker image is 8MB want het gebruikt de host kernel  
en is geoptimaliseerd voor virtualizatie, dus heeft alleen virtualizatie drivers.  
Nu kan je docker image verwijderen met docker image rm en docker containers met docker rm.
```shell
docker image rm id
# of de alias
docker rmi id
```
Dus om docker images te gebruiken en beheren gebruik je
```shell
# voor bouwen
docker build -t tag -f dockerfile
# voor een lijst van images
docker image ls
# voor verwijderen
docker image rm id
```
Om meer te leren over de docker cli kan je docker --help doen.
```shell
docker --help
```
en door de documentatie te lezen [Docker docs](https://docs.docker.com/).

**TODO Opdracht: refactor de neofetch dockerfile om alpine linux te gebruiken in plaats van debian**
**TODO Opdracht: refactor applicatie om containers te gebruiken (bash script) (requires installation of een package)**
**TODO** voor productie is het nodig om alle binaries en source files in de image zelf te hebben, zodat je niet zelf de html, php, js etc.
files hoeft te mounten.

---
## Docker compose

docker compose is nodig als je met meerdere containers begint te werken.  
Het handmatig opstarting en stoppen en verwijderen van containers is natuurlijk niet handig als je het hebt over grootte  
aantallen containers die samenwerken om je applicatie te draaien.  
Dit kan je automatiseren met shell scripten, maar dan moet je ook zelf container images downloaden en komen heel wat andere  
**dingen** bij die je zou moeten automateseren,  
Dus het zou handing zijn om het **declaritive** the kunnen schrijven.  
Docker compose is de tool die gemaakt is om zo containers te besturen.  
In plaats van handmatig image te downloading & een script te hoeven updaten op elke verandering zoals een dependency van
een container bij een andere container nodig heeft,
bijvoorbeeld een webapp die een memcache container gebruikt voor caching.
Je kan een docker-compose.yml [yaml](https://wikiless.tiekoetter.com/wiki/YAML?lang=en) text file schrijven.  
**TODO docker manual commands comparison to docker-compose workflow**
geef analyse over verschillende opties in docker compose en vergelijkende 
[compose reference](https://docs.docker.com/compose/compose-file/)


## Container orchistratie
-

