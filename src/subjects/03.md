---
title: Praktisch docker
order: 1
active: 1
goto:
 type: subject
 index: 4
---

# Praktisch docker

**TODO** scenarios waarbij docker goede oplossing is
**TODO** makkelijk redundancy
wie hoe wat waar wanneer waarom docker
containers maken efficienter gebruikt van de host os resources dan virtuele machines, maar gebruiken dezelfde kernel als het host operating systeem
voor containers hoef je niet rekening te houden met de state vm configuraties, dat hoeft anders ook niet met een vm orchestrator
Docker is een runtime voor containers die de oci standaard gebruiken.
Containers zijn een lighte virtualisatie technologie gebouwd op de linux kernel.
Docker word gebruikt
- om programmas onafhankelijk van operating systeem en systeem configuratie op te zetten
    Dit betekend bijvoorbeeld dat je programmas die verschillende versies hebben op dezelfde computer kan draaien
- om te prototypen
    Als er iets verkeerd gaat met het opzetten van bijvoorbeeld een database,
    dan is dat heel gemakkelijk terug te zetten.
- om te experiementeren
    Als je met een container werkt is dat onafhankelijk van het operating systeem, dus je kan niet je firewall verknallen!
- voor security
    security werkt met lagen en de docker runtime isoleert het van het host systeem met de juiste configuraties
- termen container vs image


---
# Docker **architectuur**
**TODO human language**
docker heeft een client & server structuur
docker engine 
Een docker applicatie wordt ingepakt tot een container image.
Om die docker applicatie te draaien moet je eerst een instantie van die image creeen, een container
De docker workflow is dus net zoals classes en objects.


---
## geschiedenis
*TODO* geschiedenis van vms tot creatie docker


---
## Containers beheren

Laten we beginnen met het hello world programma!
```shell
docker run --rm hello-world
```
Nu zie je docker een image downloaden van de standard image repository: dockerhub.  
Dan draait docker een container instantie en als het programma klaar is verwijderd docker de container vanwege de --rm (remove) optie.  
Nu heeft docker nog wel de image dat als het waare een blauwprint is.  
Gebruik docker image ls een de gedownloade images weer te geven.
```shell
docker image ls
```
*TODO*
run
run --rm
ps
ps -a
rm

Dus om docker images te gebruiken en beheren gebruik je
```shell
# voor draaien
docker run imageid
# voor een lijst van draaiende containers
docker ps
# voor een lijst van active en inactive containers
docker ps -a
# voor een container verwijderen
docker rm id
```


---
## Container images

Een docker image werkt door lagen van applicaties te installeren & commandos te draaien op een andere image.
Onder al die lagen zit een basis image, die wel speciale preperatie nodig heeft [base images](https://docs.docker.com/build/building/base-images/)
Maar je werkt in de praktijk vrijwel altijd al met een base image, zoals debian of alpine linux.
Net zoals je in windows en linux na een installatie allemaal programmas installeerd, doen we dat ook met docker images.
Linux distributies gebruiken een package manager net zoals npm, composer etc. voor gewone programmas installeren.
Om bijvoorbeeld videolan te installeren gebruik je op archlinux, die de pacman package manager gebruikt
```shell
pacman -S vlc
```
Een package manager verifieerd package integeriteit en maakt het makkelijk om programmas te installeren.
Nou zo'n docker image bouwen doe je met een **Dockerfile**.
Een dockerfile is een text file met de volgende structuur:
```dockerfile
FROM debian:latest
# dit is waar je de base image kiest, hierzo debian van de standard repository (dockerhub) met de latest tag (de laatste versie).

RUN apt update && apt install neofetch
# de RUN instructie wordt gebruikt een commandos uit te voeren.
# hier updaten we eerst de package database, oftewel welke programmas de package manager het bestaan van weet.
# apt is het commando van de debian package manager aptitude.
# en (&&) hier installeren we het programma neofetch, dat wordt gebruikt om informatie over een operating systeem laat zien.

RUN echo hallo we zijn een image aan het bouwen!
# als we deze Dockerfile gebruiken om een image te bouwen, zullen we "hallo we zijn een image aan het bouwen!" te zien krijgen.
# het sh echo commando print naar stdout, oftewel het doet hetzelfde als echo en print in programmeer talen>

ENTRYPOINT [ "neofetch" ]
# entrypoint is het commando dat wordt gedraaid, als je een container van deze image gebruikt.
```
andere dockerfile commands zijn COPY, CMD. Zie de [referentie](https://docs.docker.com/engine/reference/builder/).
Om je docker image daadwerkelijk te bouwen gebruik je docker build.
Open een shell in de Dockerfile folder.
```shell
# build een image van context folder (zoekt een Dockerfile in dezelfde folder)
docker build -t mijn-neofetch .
# of een specifieke Dockerfile
docker build -t mijn-neofetch -f Dockerfile
```
Nu download docker de debian image en gaat het laag voor laag bouwen.
Je ziet als docker klaar is met bouwen na STEP 3/4 een lijn: 'hallo we zijn een image aan het bouwen!'
Nu kunnen we neofetch in een container draaien met docker run.
```shell
docker run --rm mijn-neofetch
```
Zoals je kunt zien met docker image ls en het downloaden & builden van de image,
gebruikt het gigantisch veel disk ruimte voor alleen maar een mooi print programma.
Een veelgebruikte operating systeem en docker base image is alpine linux, omdat het heel klein is.
De alpine docker image is 8MB want het gebruikt de host kernel  
en is geoptimaliseerd voor virtualizatie, dus heeft alleen virtualizatie drivers.
**TODO Opdracht: refactor de neofetch dockerfile om alpine linux te gebruiken in plaats van debian**
**TODO Opdracht: refactor applicatie om containers te gebruiken (bash script) (requires installation of jq package)**
Nu kan je docker image verwijderen met docker image rm en docker containers met docker rm.
```shell
docker image rm id
# of de alias
docker rmi id
```
Dus om docker images te gebruiken en beheren gebruik je
```shell
# voor bouwen
docker build -t tag -f dockerfile
# voor een lijst van images
docker image ls
# voor verwijderen
docker image rm id
```
Om meer te leren over de docker cli kan je docker --help doen.
```shell
docker --help
```
en door de documentatie te lezen [Docker docs](https://docs.docker.com/).


---
## Docker compose

docker compose is nodig als je met meerdere containers begint te werken.  
Het handmatig opstarting en stoppen en verwijderen van containers is natuurlijk niet handig als je het hebt over grootte  
aantallen containers die samenwerken om je applicatie te draaien.  
Dit kan je automatiseren met shell scripten, maar dan moet je ook zelf container images downloaden en komen heel wat andere  
**dingen** bij die je zou moeten automateseren,  
Dus het zou handing zijn om het **declaritive** the kunnen schrijven.  
Docker compose is de tool die gemaakt is om zo containers te besturen.  
In plaats van handmatig image te downloading & een script te hoeven updaten op elke verandering zoals een dependency van
een container bij een andere container nodig heeft,
bijvoorbeeld een webapp die een memcache container gebruikt voor caching.
Je kan een docker-compose.yml [yaml](https://wikiless.tiekoetter.com/wiki/YAML?lang=en) text file schrijven.  
**TODO docker manual commands comparison to docker-compose workflow**
geef analyse over verschillende opties in docker compose en vergelijkende 
[compose reference](https://docs.docker.com/compose/compose-file/)


## Container orchistratie
-

